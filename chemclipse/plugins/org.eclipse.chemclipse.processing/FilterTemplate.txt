All Filters for a specific itemtype should comply with the following pattern where

[ItemType] is the type of the item to be filtered

/**
 * A {@link Filter} Extension interface for filters that can work on {@link [ItemType]}s.
 * This is part of the Chemclipse FilterFramework, to make the Filter available simply register it with the OSGi Servicefactory under the {@link Filter} interface, implementors are encouraged to also register each filter under all sub(filter) interface.
 * 
 * @author Christoph LÃ¤ubrich
 *
 * @param <ConfigType>
 */
public interface [ItemType]Filter<ConfigType> extends Filter<ConfigType> {

	/**
	 * Filters the given Collection of {@link [ItemType]}s with this filter and returns the result.
	 * The resulting Collection could either be the same or a new collection, might have more or less items
	 * 
	 * @param filterItems
	 * @param configuration
	 *            the configuration to apply or <code>null</code> if no special configuration is desired
	 * @param nextFilter
	 *            the next filter to invoke, implementors might allow further processing with other filters in the chain by calling {@link FilterChain#doFilter(Object, org.eclipse.chemclipse.processing.core.MessageConsumer)}
 	 * @param messageConsumer
	 *            Filters are meant to not throwing checked exceptions nor return no result if something goes wrong but report problems to the {@link MessageConsumer} this allows the upstream caller to decide what to do
	 * @param monitor
	 *            a {@link IProgressMonitor} to report progress of the filtering or <code>null</code> if no progress is desired
	 * @return a {@link IProcessingResult} that describes the outcome of the filtering, the result will be {@link Boolean#TRUE} if any item in the list was filter or {@link Boolean#FALSE} if no item was filtered or there was an error. The messages of the {@link IProcessingResult} may contain further information
	 * @throws IllegalArgumentException
	 *             if any of the given {@link [ItemType]} are incompatible with this filter ({@link #accepts[ItemType]([ItemType])} returns <code>false</code> for them)
	 */
	Collection<? extends [ItemType]> filter[ItemType]s(Collection<? extends [ItemType]> filterItems, ConfigType configuration, FilterChain<Collection<? extends [ItemType]>> nextFilter, MessageConsumer messageConsumer, IProgressMonitor monitor) throws IllegalArgumentException;

	/**
	 * Checks if the given {@link [ItemType]} is compatible with this filter, that means that this filter can be applied without throwing an {@link IllegalArgumentException}
	 * 
	 * @param item
	 *            the {@link [ItemType]} to check
	 * @return <code>true</code> if this {@link [ItemType]} can be applied, <code>false</code> otherwise
	 */
	default boolean accepts[ItemType]s(Collection<? extends [ItemType]> items) {

		for([ItemType] item : items) {
			if(!accepts[ItemType](item)) {
				return false;
			}
		}
		return true;
	}

	boolean accepts[ItemType]([ItemType] item);

	/**
	 * Creates a new configuration that is specially suited for the given {@link [ItemType]} types
	 * 
	 * @param item
	 * @return a new configuration for this items or the default config if items is empty or no suitable configuration can be created
	 * @throws IllegalArgumentException
	 *             if any of the given {@link [ItemType]} are incompatible with this filter ({@link #accepts[ItemType]([ItemType])} returns <code>false</code> for them)
	 */
	default ConfigType createConfiguration(Collection<? extends [ItemType]> items) throws IllegalArgumentException {

		if(accepts[ItemType]s(items)) {
			for([ItemType] item : items) {
				return createConfiguration(item);
			}
			return createNewConfiguration();
		} else {
			throw new IllegalArgumentException("incompatible items in collection");
		}
	}

	/**
	 * Creates a configuration for this single item
	 * 
	 * @param item
	 * @return a new configuration for this items or the default config if items is empty or no suitable configuration can be created
	 * @throws IllegalArgumentException
	 *             if any the given {@link [ItemType]} is incompatible with this filter ({@link #accepts[ItemType]([ItemType])} returns <code>false</code> for them)
	 */
	default ConfigType createConfiguration([ItemType] item) throws IllegalArgumentException {

		return createNewConfiguration();
	}
}